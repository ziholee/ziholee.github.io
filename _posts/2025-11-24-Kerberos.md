---
title: "[정보보안] Kerberos"
author: ziho
date: 2025-11-24
categories: [Security, Crypto]
tags: [crypto, kerberos]
pin: true
math: true
---

다음은 정보보안에서 케베로스에 관한 이야기이다.

---

### 1. Kerberos 개요 및 특징

#### 정의 및 유래

![kerberos](/assets/img/kerberos.png)

*   Kerberos는 그리스 신화에서 하데스의 입구를 지키는 **머리가 3개 달린 개**의 이름에서 유래했다.
*   보안 분야에서 Kerberos는 **대칭 키 암호화**를 기반으로 하는 **인증 프로토콜**이다.
*   이 프로토콜은 **MIT(매사추세츠 공과대학)**에서 시작되었으며, Needham과 Schroeder의 연구를 기반으로 한다.
*   Kerberos는 **싱글 사인온(single sign-on)** 기능을 제공하는 실세계 프로토콜 중 하나다.

#### 확장성 및 구조
*   Kerberos는 **신뢰할 수 있는 제3자(TTP, Trusted Third Party)**인 **KDC(Key Distribution Center)**에 의존한다.
*   **KDC**는 TTP 역할을 수행하므로 **보안이 유지되어야 하며 훼손되어서는 안된다.**.
*   일반적인 대칭 키 인증은 $N$명의 사용자에게 약 $N^2$개의 키가 필요하지만, Kerberos는 대칭 키를 기반으로 하면서도 **$N$명의 사용자에게 $N$개의 키만** 필요로 한다.
*   Kerberos를 사용하면 PKI(공개 키 인프라)가 필요하지 않으며, 보안은 KDC(TTP)에 의존한다.

#### 키 관리

![kerberos_key](/assets/img/kerberosKey.jpg)

*   KDC는 각 사용자(Alice, Bob, Carol 등)와 각각 대칭 키($K_A$, $K_B$, $K_C$ 등)를 공유한다.
*   KDC는 **오직 자신만이 아는 마스터 키 $K_{KDC}$**를 가지고 있다.
*   KDC는 인증을 가능하게 하고, **기밀성 및 무결성**을 위한 **세션 키** 설정을 가능하게 한다.

### 2. Kerberos 프로토콜의 3단계 과정

Kerberos는 사용자가 네트워크 자원에 접근하기 위해 TGT(Ticket-Granting Ticket)를 획득하고, 이를 사용하여 특정 서버(Bob)와의 세션 키를 설정하는 3단계로 진행된다.

#### 1단계: 로그인 및 TGT(Ticket-Granting Ticket) 획득
1.  **패스워드 입력:** Alice가 자신의 패스워드를 입력한다.
2.  **$K_A$ 도출:** Alice의 컴퓨터는 패스워드로부터 Alice의 키인 $K_A$를 도출한다.
3.  **TGT 요청:** Alice의 컴퓨터는 $K_A$를 사용하여 KDC로부터 Alice를 위한 **TGT**를 요청한다.
4.  **KDC 응답:**
    *   KDC는 **세션 키 $S_A$**를 생성합니다.
    *   KDC는 **$E(S_A, \text{TGT}, K_A)$**를 Alice에게 보냅니다.
5.  **TGT 정의:** TGT 자체는 **$E(\text{"Alice"}, S_A, K_{KDC})$**로 암호화됩니다. TGT는 $K_{KDC}$로 암호화되어 **오직 KDC만이 읽을 수 있다**.
6.  **TGT 정보:** TGT는 **세션 키, 사용자 ID, 만료 시간**을 포함한다.
7.  **$K_A$ 삭제:** Alice의 컴퓨터는 $S_A$와 TGT를 복호화한 후, **$K_A$를 잊어버린다**.

> *참고: $E(\text{TGT}, K_A)$가 추가적인 보안을 제공하지 않음에도 불구하고 TGT를 $K_A$로 암호화하는 것은 불필요한 작업이라는 지적이 있다.*

#### 2단계: Bob과의 통신을 위한 티켓 요청
1.  **요청 (REQUEST):** Alice가 Bob과 통신하기를 원할 때, KDC에게 **REQUEST**를 보낸다.
2.  **REQUEST 구성:** REQUEST는 **(TGT, authenticator)**로 구성된다.
3.  **Authenticator:** $\text{authenticator} = E(\text{timestamp}, S_A)$ 다.
4.  **KDC 검증:** KDC는 TGT로부터 $S_A$를 얻어 **타임스탬프를 검증**한다.
5.  **응답 (REPLY):** KDC는 Alice에게 **REPLY**를 보낸다.
6.  **REPLY 구성:** $\text{REPLY} = E(\text{"Bob"}, K_{AB}, \text{ticket to Bob}, S_A)$ 입니다. 여기서 $K_{AB}$는 Alice와 Bob 사이의 세션 키다.
7.  **Ticket to Bob 정의:** $\text{ticket to Bob} = E(\text{"Alice"}, K_{AB}, K_B)$ 다.

#### 3단계: Bob에게 티켓을 사용하여 접근
1.  **Bob에게 전송:** Alice는 Bob에게 **ticket to Bob**과 새로운 **authenticator**를 보낸다.
2.  **Authenticator:** $\text{authenticator} = E(\text{timestamp}, K_{AB})$ 다.
3.  **Bob의 세션 키 획득:** Bob은 자신의 키 $K_B$를 사용하여 **"ticket to Bob"을 복호화**하고, 이로써 세션 키 **$K_{AB}$를 얻는다**.
4.  **검증:** Bob은 $K_{AB}$를 사용하여 $\text{authenticator}$의 **타임스탬프를 검증**한다.

### 3. Kerberos의 보안 및 설계 원칙

*   **타임스탬프 사용:** Kerberos는 인증 및 **재전송 공격 방지(replay protection)**를 위해 **타임스탬프**를 사용한다. 타임스탬프는 미리 알려진 **논스(nonce)**와 유사하여 메시지 수를 줄이지만, **'시간' 자체가 보안에 중요한 매개변수**가 된다.
*   **투명성:** 일단 Alice가 로그인하면, 이후 네트워크 자원에 안전하게 접근하는 과정은 Alice에게 **투명하게** 이루어진다.
*   **상태 비저장 KDC (Stateless KDC):** Kerberos의 주요 특징은 KDC가 **상태 비저장(stateless)**이라는 것이다. KDC가 세션 키를 기억하는 대신 TGT에 넣어 보내는 것은 KDC의 상태 비저장성을 유지하기 위함이다. 만약 KDC가 세션 키를 기억한다면 TGT가 필요 없을 수도 있다.
*   **티켓 전달 이유:** "ticket to Bob"이 KDC에서 Bob에게 직접 전송되지 않고 Alice에게 전송되는 이유 역시 KDC의 상태 비저장성 유지와 관련이 있다.